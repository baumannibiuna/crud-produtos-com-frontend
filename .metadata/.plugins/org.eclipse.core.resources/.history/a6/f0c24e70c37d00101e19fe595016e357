package com.exemplo.crudprodutos.controller;

//Importando as classes e anotações necessárias.
import com.exemplo.crudprodutos.model.Produto;
import com.exemplo.crudprodutos.repository.ProdutoRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;

//A anotação @RestController combina duas anotações: @Controller e @ResponseBody.
//@Controller marca a classe como um controlador do Spring MVC (Model-View-Controller).
//@ResponseBody indica que o valor de retorno dos métodos deve ser escrito diretamente no corpo da resposta HTTP (geralmente em JSON).
@RestController
//A anotação @RequestMapping define o caminho (URL) base para todos os endpoints neste controlador.
//Todas as requisições que começarem com "/api/produtos" serão direcionadas para esta classe.
@RequestMapping("/api/produtos")
@CrossOrigin(origins = "http://localhost:3000")
public class ProdutoController {

 // A anotação @Autowired realiza a "injeção de dependência".
 // O Spring vai criar automaticamente uma instância de ProdutoRepository e injetá-la nesta variável.
 // Assim, não precisamos nos preocupar em criar o objeto `produtoRepository` manualmente.
 @Autowired
 private ProdutoRepository produtoRepository;

 // --- CREATE (Criar) ---
 // A anotação @PostMapping mapeia requisições HTTP do tipo POST para este método.
 // Usamos POST para criar novos recursos. O endpoint completo será: POST /api/produtos
 @PostMapping
 public Produto criarProduto(@RequestBody Produto produto) {
     // @RequestBody diz ao Spring para pegar o corpo da requisição (que virá em formato JSON)
     // e converter para um objeto da classe Produto.
     // O método save() do JpaRepository serve tanto para criar (se o ID for nulo) quanto para atualizar.
     // Ele retorna o produto salvo (agora com o ID gerado pelo banco).
     return produtoRepository.save(produto);
 }

 // --- READ (Ler) ---
 // A anotação @GetMapping mapeia requisições HTTP do tipo GET.
 // Este método buscará TODOS os produtos. O endpoint completo será: GET /api/produtos
 @GetMapping
 public List<Produto> listarTodosProdutos() {
     // O método findAll() do JpaRepository retorna uma lista com todos os registros da tabela de produtos.
     return produtoRepository.findAll();
 }

 // Este método buscará UM produto pelo seu ID.
 // O "{id}" na URL é uma "variável de caminho" (path variable).
 // O endpoint completo será, por exemplo: GET /api/produtos/1
 @GetMapping("/{id}")
 public ResponseEntity<Produto> buscarProdutoPorId(@PathVariable("id") Long id) {
     // @PathVariable Long id pega o valor do "id" da URL e o coloca na variável `id` do método.
     // O método findById() retorna um `Optional`. `Optional` é um container que pode ou não conter um valor.
     // Isso nos ajuda a evitar erros de "ponteiro nulo" (NullPointerException).
     Optional<Produto> produto = produtoRepository.findById(id);

     // Se o produto foi encontrado (isPresent()), retornamos uma resposta HTTP 200 OK com o produto no corpo.
     // Se não, retornamos uma resposta HTTP 404 Not Found (não encontrado).
     // ResponseEntity nos dá mais controle sobre a resposta HTTP (código de status, cabeçalhos, etc.).
     if (produto.isPresent()) {
         return ResponseEntity.ok(produto.get());
     } else {
         return ResponseEntity.notFound().build();
     }
 }

 // --- UPDATE (Atualizar) ---
 // A anotação @PutMapping mapeia requisições HTTP do tipo PUT.
 // Usamos PUT para atualizar um recurso existente. O endpoint será, por exemplo: PUT /api/produtos/1
 @PutMapping("/{id}")
 public ResponseEntity<Produto> atualizarProduto(@PathVariable("id") Long id, @RequestBody Produto detalhesProduto) {
     // Primeiro, buscamos o produto existente no banco de dados.
     Optional<Produto> produtoOptional = produtoRepository.findById(id);

     // Se o produto não existir, retornamos 404 Not Found.
     if (!produtoOptional.isPresent()) {
         return ResponseEntity.notFound().build();
     }

     // Se ele existe, pegamos o objeto Produto de dentro do Optional.
     Produto produtoExistente = produtoOptional.get();

     // Atualizamos os campos do produto existente com os dados recebidos na requisição.
     produtoExistente.setNome(detalhesProduto.getNome());
     produtoExistente.setDescricao(detalhesProduto.getDescricao());
     produtoExistente.setPreco(detalhesProduto.getPreco());

     // Salvamos o produto atualizado de volta no banco. O método save() percebe que o ID já existe
     // e, em vez de criar um novo, atualiza o registro existente.
     final Produto produtoAtualizado = produtoRepository.save(produtoExistente);
     // Retornamos a resposta 200 OK com o produto já atualizado.
     return ResponseEntity.ok(produtoAtualizado);
 }

 // --- DELETE (Deletar) ---
 // A anotação @DeleteMapping mapeia requisições HTTP do tipo DELETE.
 // Usamos DELETE para remover um recurso. O endpoint será, por exemplo: DELETE /api/produtos/1
 @DeleteMapping("/{id}")
 public ResponseEntity<Void> deletarProduto(@PathVariable("id") Long id) {
     // Primeiro, verificamos se o produto que queremos deletar realmente existe.
     if (!produtoRepository.existsById(id)) {
         // Se não existir, retornamos 404 Not Found.
         return ResponseEntity.notFound().build();
     }

     // Se existir, chamamos o método deleteById() para removê-lo do banco.
     produtoRepository.deleteById(id);

     // Para operações de delete bem-sucedidas, é comum retornar uma resposta 204 No Content,
     // que significa "A operação foi um sucesso, mas não há nada para mostrar no corpo da resposta".
     return ResponseEntity.noContent().build();
 }
}